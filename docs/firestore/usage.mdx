---
title: Cloud Firestore
sidebar_label: Usage
---

> This documentation is a work in progress

## Collections & Documents

Cloud Firestore stores data within "documents", which are contained within "collections".  Documents can also contain
nested collections.  For example, our users would each have their own "document" stored inside the "Users" collection.
The `collection` method allows us to reference a collection within our code.  In the below example, we can reference
the collection `users`, and create a new user document:

```dart title="lib/main.dart"
import 'package:flutter/material.dart';

// Import the firebase_core and cloud_firestore plugin
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

// Create a CollectionReference called users that references the firestore collection
CollectionReference get users => firestore.collection('users');

// Call the _addNewUser function to add a new user
Future<void> _addNewUser() async {
    await users.add(<String, dynamic>{
      'first_name': 'John',
      'last_name': ' Smith',
      'created_at': FieldValue.serverTimestamp(),
    });
}
```



## Read Data

Cloud Firestore gives you the ability to read the value of a collection or a document.  This can be a one-time read, or
provided by realtime updates when the data within a query changes.

### One-time Read

To read a collection or document once, call the `getDocuments` method on a `CollectionReference` or `DocumentReference`

```dart
Firestore.instance
    .collection('users')
    .document(userId)
    .getDocuments();
```

### Realtime changes


> Check code <br/>
  Snapshot doesn't error on permission error


```dart
class UserList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot> (
      stream: Firestore.instance.collection('users').snapshots(),
      builder: (context, AsyncSnapshot<QuerySnapshot> snapshot) {
        if(snapshot.hasError) {
          return new Text('Error: ${snapshot.error}', textDirection: TextDirection.ltr);
        }

        if(snapshot.connectionState == ConnectionState.active) {
          return new ListView(
            children: snapshot.data.documents.map((DocumentSnapshot document) {
              return new ListTile(
                title: new Text(document['first_name'], ),
                subtitle: new Text(document['last_name'])
              );
            }).toList(),
          );
        }

        return Padding(
          padding: const EdgeInsets.all(50.0),
          child: new Text('Loading Data', textDirection: TextDirection.ltr),
        );

      },
    );
  }
}
```

### Snapshots

When making a Firestore Query, Firestore returns either a `QuerySnapshot` for collection queries, or a `DocumentSnapShot`
for document queries.  These snapshots provide the ability to view the data, view query metadata, whether the document
exists or not and more.

#### QuerySnapshot

A `QuerySnapshot` is returned from a collection query, and allows you to inspect the collection, such as how many documents
exist within it, gives access to the documents within the collection, see any changes since the last query and more.document

To access the documents within a `QuerySnapshot`, call the `forEach` method:

```dart
Firestore.instance
    .collection('users')
    .snapshots()
    .listen((QuerySnapshot) => {
        QuerySnapshot.documents.forEach((doc) {
            print(doc["first_name"]);
        });
    });
```
Each child document of a `QuerySnapshot` is a `QueryDocumentSnapshot`, which allows you to access specific information
about a document (see below).

#### DocumentSnapshot

A `DocumentSnapShot` is returned from a query or as part of the documents returned via a `QuerySnapshot`.  The snapshot
provides the ability to view a documents data, metadata and whether the document actually exists.snapshot

To view a documents data, call the `data` method on the snapshot:

```dart
Firestore.instance
    .collection('users')
    .document(userId)
    .get()
    .then((DocumentSnapshot documentSnapshot) {
        print('User Exists: $documentSnapshot.exists');

        if(documentSnapshot.exists) {
            print(documentSnapshot['first_name']);
        }
    });
```

### Querying

Cloud Firestore offers advanced capabilities for querying collections.

#### Filtering

To filter documents within a collection, the `where` method can be chained onto a collection reference.  Filtering supports
equality checks and "in" queries.  For example, for filter users where their age is greater than 30:

```dart
Firestore.instance
    .collection('users')
    .where('age', isGreaterThan: 30)
    .snapshots()
    .listen((QuerySnapshot) => {
        /* ... */
    });
```

Cloud Firestore also supports array queries.  For example, to filter users who speak English(en) or Italian (it), use
the `arrayContainsAny` filter:

```dart
Firestore.instance
    .collection('users')
    .where('languages', arrayContainsAny: ['en', 'it'])
    .snapshots()
    .listen((QuerySnapshot) => {
        /* ... */
    });
```

To learn more about all of the querying capabilities Cloud Firestore has to offer, view the
[Firebase documentation](https://firebase.google.com/docs/firestore/query-data/queries).


#### Limiting

To limit the number of documents returned from a query, use the `limit` method on a collection reference:

```dart
    Firestore.instance
        .collection('users')
        .limit(2)
        .snapshots()
        .listen((QuerySnapshot) => {
            /* ... */
        });
```

#### Ordering

To order the documents by a specific value, use the `orderBy` method:

```dart
    Firestore.instance
        .collection('users')
        .limit(20)
        .orderBy('age', descending: false)
        .snapshots()
        .listen((QuerySnapshot) => {
            /* ... */
        });
```

The above example both limits the documents returned to 20 and orders all the users in the snapshot page age ascending order

#### Start/End

To start and/or end a query at a specific point within a collection, you can pass a value to the `startAt`, `endAt`,
`startAfter` or `endBefore` methods.  You must specific an order to use pointers, for example:

```dart
Firestore.instance
    .collection('users')
    .orderBy('age', descending: false)
    .startAt([19])
    .endAt([40])
    .snapshots()
    .listen((QuerySnapshot) => {
        /* ... */
    });
```

The above query orders users by age in ascending order, but only returns users whose age is between 19 and 40.

You can further specify a `DocumentSnapShot` instead of a specific value, by passing it to the `startAfterDocument`,
`startAtDocument`, `endAtDocument` or `endBeforeDocument` methods.  For example:

```dart
var userDocumentSnapshot = await Firestore.instance
    .collection('users')
    .document(userId)
    .get();

Firestore.instance
    .collection('users')
    .orderBy('age')
    .startAfterDocument(userDocumentSnapshot)
    .snapshots()
    .listen((QuerySnapshot) => {
        /* ... */
    });
```


#### Query Limitations

Cloud Firestore does not support the following types of queries:

- Queries with range filters on different fields, as described in the previous section.
- Logical OR queries.  In this case, you should create a separate query for each OR condition and merge the query results
in your app.
- Queries with a != clause.  In this cause, you should split the query into a greater-than query and a less-than query.
For example, the query clause `where("age", isNotEqualTo: 30)` is not supported, however you can get the same result set
by combining two queries, one with the clause `where("age", isLessThan: 30)` and one with the clause
`where("age", isGreaterThan: 30)`

## Writing Data

The [Firebase Documentation](https://firebase.google.com/docs/firestore/manage-data/structure-data) provides some great
examples on the best practices to structuring your data. It is recommended that you read the guide before building your
database.

For more information on what is possible when writing data to Firestore, please refer to this [documentation](https://firebase.google.com/docs/firestore/manage-data/add-data)

## Adding Documents

To add a new document to a collection, use the `add` method on a `CollectionReference`:

```dart
Firestore.instance
    .collection('users')
    .add({
        'first_name': 'Ben',
        'last_name': 'Jones',
        'age': 26
    })
    .then(() => print('User Added'));
```

The `add` method adds the new document to your collection with a unique auto-generated ID. If you'd like to specify your
own ID, call the `setData` method on a `DocumentReference` instead:

```dart
Firestore.instance
    .collection('users')
    .document('ABC123')
    .setData({
        'first_name': 'Steve',
        'last_name': 'Austin',
        'age': 52
    });
```
### Updating documents

The `setData` method above replaces any existing data on a given `DocumentReference`.  If you'd like to update a document
instead, use the `update` method:

```dart
Firestore.instance
    .collection('users')
    .document('ABC123')
    .updateData({
        'age': 25
    });
```

The method also provides support for updating deeply nested values via dot-notation:

```dart
Firestore.instance
    .collection('users')
    .document('ABC123')
    .updateData({
        'info.address.zipcode': 90210
    });
```

#### Field values

Cloud Firestore supports storing and manipulating values on your database, such as Timestamps, GeoPoints, Blobs and
array management.document

To store `GeoPoint` values, provide the latitude and longitude to the GeoPoint class:

```dart
Firestore.instance
    .collection('users')
    .document('ABC123')
    .updateData({
        'info.address.location': GeoPoint(53.483959, -2.244644)
    });
```

To store a Blob such as an image, provide a `Uint8List`.  The below example shows how to get a remote image as a `Uint8List`
and nest it within a `document`:

```dart
Uint8List data =
  (await NetworkAssetBundle(Uri.parse('https://i.imgur.com'))
    .load("/HTm48iG.jpg"))
    .buffer
    .asUint8List();

Firestore.instance
  .collection('users')
  .document('ABC123')
  .updateData({
    'info.avatar': Blob(data)
  });
```

## Removing Data

To delete documents with Cloud Firestore, you can use the `delete` method on a `DocumentReference`:

```dart
Firestore.instance
  .collection('users')
  .document('ABC123')
  .delete()
```

If you need to remove specific properties from within a document rather than the document itself, you can use the `delete`
method on the `FieldValue` class:

```dart
Firestore.instance
  .collection('users')
  .document('ABC123')
  .updateData({
    'age': FieldValue.delete()
  });
```

## Transactions

Transactions are a way to ensure that a write operation only occurs using the latest data available on the server.
Transactions never partially apply writes, and writes execute at the end of a successful transaction.

Transactions are useful when you want to update a field based on its current value, or the value of another field.  If
you want to write multiple documents without using the documents current state, a [batch write](usage#batch-write)
should be used.

When using transactions, note that:

- Read operations must come before write operations
- Transactions will fail is the client is offline, they cannot use cached data

An example of where a transaction could be used would be in an application where a user can subscribe to a channel. When
a user presses the subscribe button, a "subscribers" field in a document increments.  Without using Transactions, we would
first need to read the existing value, and then increment that value using two separate operations.

On a high traffic application, the value on the server could have already changed by the time the write operation sets
a new value, causing the number to be inconsistent.

Transactions remove this issue by atomically updating the value of the server.  If the value changes whilst the transaction
is executing, it will retry, ensuring the value on the server is used, rather than the client value.

To execute a transaction, call the `runTransaction` method:

```dart
DocumentReference docRef = Firestore.instance.document('users/ABC123');

Firestore.instance.runTransaction(( Transaction transaction) async {
  DocumentSnapshot docSnap = await transaction.get(docRef);

  transaction.update(docRef, {
    'subscribers':docSnap.data['subscribers'] + 1
  })
  .whenComplete(() => print("Subscriber count updated"));
});
```


## Batch write

Firestore lets you execute multiple write operations as a single batch that can contain any combination of `set`, `update`,
or `delete` operations.

First, create a new batch instance via the `batch` method, then perform the operations on the batch, and then commit it
once ready.  The below example shows how to delete all documents in a collection in a single operation:

```dart
QuerySnapshot userQs = await Firestore.instance
  .collection('users')
  .getDocuments();

var batch = Firestore.instance.batch();

userQs.documents.forEach((doc) {
  batch.delete(doc.reference);
});

return batch.commit();
```

## Data Security

It is important that you understand how to write rules in your Firebase console to ensure that your data is secure.
Please follow the Firebase Firestore documentation on [security](https://firebase.google.com/docs/firestore/security/get-started).

## Offline Capabilities

Firestore provides out of the box support for offline capabilities.  When reading and writing data, Firestore uses a
local database which automatically synchronizes with the server. Cloud Firestore functionality continues when users are
offline, and automatically handles data migration when they regain connectivity.capabilities

This functionality is enabled by default, however it can be disabled if needed.  The `settings` method must be called
before any Firestore interaction is performed:

```dart
await Firestore.instance.settings(
  persistenceEnabled: false
);
```




